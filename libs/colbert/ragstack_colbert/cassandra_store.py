"""
This module provides an implementation of the ColbertVectorStore abstract base class, specifically designed
for use with a Cassandra database backend. It allows for the efficient storage and management of text embeddings
generated by a ColBERT model, facilitating scalable and high-relevancy retrieval operations.
"""

import logging
from typing import List, Optional

from cassandra.cluster import Session
from cassandra.concurrent import execute_concurrent_with_args

from .token_embedding import EmbeddedChunk
from .vector_store import ColbertVectorStore


class CassandraColbertVectorStore(ColbertVectorStore):
    """
    An implementation of the ColbertVectorStore abstract base class using Cassandra as the backend
    storage system. This class provides methods to store, retrieve, and manage text embeddings within
    a Cassandra database, specifically designed for handling vector embeddings generated by ColBERT.

    Attributes:
        session (Session): The Cassandra session instance used for database operations.
        keyspace (str): The name of the Cassandra keyspace to use.
        table_name (str): The name of the table within the keyspace for storing chunk embeddings.
        full_table_name (str): The full name of the table (including keyspace) for queries.
        insert_chunk_stmt (PreparedStatement): Prepared statement for inserting text chunks.
        insert_colbert_stmt (PreparedStatement): Prepared statement for inserting embeddings.
        query_colbert_ann_stmt (PreparedStatement): Prepared statement for ANN queries.
        query_colbert_chunks_stmt (PreparedStatement): Prepared statement for retrieving chunks.
        query_chunk_stmt (PreparedStatement): Prepared statement for retrieving chunk bodies.
        delete_chunks_by_doc_id_stmt (PreparedStatement): Prepared statement for deleting chunks.

    The table schema and custom index for ANN queries are automatically created if they do not exist.
    """

    session: Session
    keyspace: str
    table_name: str

    def __init__(
        self, session: Session, keyspace: str, table_name: str, timeout: int = 180
    ):
        """
        Initializes a new instance of the CassandraColbertVectorStore.

        Parameters:
            session (Session): The Cassandra session to use.
            keyspace (str): The keyspace in which the table exists or will be created.
            table_name (str): The name of the table to use or create for storing embeddings.
            timeout (int, optional): The default timeout in seconds for Cassandra operations. Defaults to 180.
        """

        self.keyspace = keyspace
        self.session = session
        self.table_name = table_name
        self.full_table_name = f"{keyspace}.{table_name}"

        self.session.default_timeout = timeout
        self.__create_tables()

        # prepare statements
        self.insert_chunk_stmt = self.session.prepare(
            f"""
        INSERT INTO {self.full_table_name} (doc_id, chunk_id, embedding_id, body)
        VALUES (?, ?, -1, ?)
        """
        )

        self.insert_colbert_stmt = self.session.prepare(
            f"""
        INSERT INTO {self.full_table_name} (doc_id, chunk_id, embedding_id, bert_embedding)
        VALUES (?, ?, ?, ?)
        """
        )

        self.query_colbert_ann_stmt = self.session.prepare(
            f"""
        SELECT doc_id, chunk_id
        FROM {self.full_table_name}
        ORDER BY bert_embedding ANN OF ?
        LIMIT ?
        """
        )

        self.query_colbert_chunks_stmt = self.session.prepare(
            f"""
        SELECT doc_id, chunk_id, bert_embedding
        FROM {self.full_table_name}
        WHERE doc_id = ? AND chunk_id = ? AND embedding_id != -1
        """
        )

        self.query_chunk_stmt = self.session.prepare(
            f"""
        SELECT body
        FROM {self.full_table_name}
        WHERE doc_id = ? AND chunk_id = ? AND embedding_id = -1
        """
        )

        self.delete_chunks_by_doc_id_stmt = self.session.prepare(
            f"""
            DELETE FROM {self.full_table_name} WHERE doc_id = ?
        """
        )

    def __create_tables(self) -> None:
        """
        Creates the necessary table and index for storing and retrieving embeddings if they do not
        already exist. This method is called during initialization.
        """

        self.session.execute(
            f"""
            CREATE TABLE IF NOT EXISTS {self.full_table_name} (
                doc_id text,
                chunk_id int,
                embedding_id int,
                body text,
                bert_embedding vector<float, 128>,
                PRIMARY KEY (doc_id, chunk_id, embedding_id)
            ) WITH COMMENT = 'Colbert embeddings embedding_id=-1 contains the body chunk';
        """
        )
        logging.info(f"Created table {self.full_table_name}")

        self.session.execute(
            f"""
            CREATE CUSTOM INDEX IF NOT EXISTS colbert_ann_{self.table_name} ON {self.full_table_name}(bert_embedding) USING 'StorageAttachedIndex'
  WITH OPTIONS = {{'similarity_function': 'DOT_PRODUCT' }};
        """
        )
        logging.info(f"Created index on table {self.full_table_name}")

    def put_chunks(
        self, chunks: List[EmbeddedChunk], delete_existing: Optional[bool] = False
    ) -> None:
        """
        Stores a list of EmbeddedChunk instances in the Cassandra database, managing both the text
        body and the embeddings of each chunk. Optionally deletes existing chunks for each document
        before insertion.

        Parameters:
            chunks (List[EmbeddedChunk]): A list of EmbeddedChunk instances to store.
            delete_existing (Optional[bool]): A flag indicating whether to delete existing chunks for the
                                              documents related to the chunks being inserted.
        """

        if delete_existing:
            doc_ids = [c.doc_id for c in chunks]
            self.delete_chunks(list(set(doc_ids)))

        p_parameters = [(c.doc_id, c.chunk_id, c.text) for c in chunks]
        execute_concurrent_with_args(self.session, self.insert_chunk_stmt, p_parameters)

        for chunk in chunks:
            doc_id = chunk.doc_id
            chunk_id = chunk.chunk_id
            parameters = [
                (doc_id, chunk_id, index, vector)
                for index, vector in enumerate(chunk.embeddings.tolist())
            ]
            execute_concurrent_with_args(
                self.session, self.insert_colbert_stmt, parameters
            )

    def delete_chunks(self, doc_ids: List[str]) -> None:
        """
        Deletes all chunks associated with the specified document identifiers.

        Parameters:
            doc_ids (List[str]): A list of document identifiers whose chunks should be deleted.
        """

        execute_concurrent_with_args(
            self.session, self.delete_chunks_by_doc_id_stmt, [(t,) for t in doc_ids]
        )

    def close(self) -> None:
        """
        Closes the Cassandra session and any other resources. This method should be overridden to
        ensure proper cleanup if necessary.
        """
        pass
